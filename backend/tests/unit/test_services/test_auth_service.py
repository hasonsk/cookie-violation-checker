import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from passlib.context import CryptContext

from src.services.auth_service.auth_service import AuthService
from src.schemas.auth import RegisterSchema, LoginSchema, RegisterResponseSchema, LoginResponseSchema
from src.schemas.user import User as UserSchema
from src.models.user import User as UserModel, UserRole
from src.exceptions.custom_exceptions import EmailAlreadyExistsError, InvalidCredentialsError, UserNotFoundError
from src.repositories.user_repository import UserRepository
from src.repositories.domain_request_repository import DomainRequestRepository
from src.utils.jwt_handler import create_access_token, decode_access_token

pwd_context_mock = MagicMock(spec=CryptContext)
pwd_context_mock.hash.return_value = "hashed_password"
pwd_context_mock.verify.return_value = True

@pytest.fixture
def mock_user_repository():
    return AsyncMock(spec=UserRepository)

@pytest.fixture
def mock_domain_request_repository():
    return AsyncMock(spec=DomainRequestRepository)

@pytest.fixture
def auth_service(mock_user_repository, mock_domain_request_repository):
    return AuthService(mock_user_repository, mock_domain_request_repository)

@pytest.fixture
def register_data():
    return RegisterSchema(
        name="Test User",
        email="test@example.com",
        password="password123",
        role=UserRole.PROVIDER
    )

@pytest.fixture
def login_data():
    return LoginSchema(
        email="test@example.com",
        password="password123"
    )

@pytest.fixture
def mock_user_model_data():
    return {
        "id": "60d5ecf0f3a7c3b2e8f1a2b3",
        "name": "Test User",
        "email": "test@example.com",
        "password": "hashed_password",
        "role": UserRole.PROVIDER,
        "approved_by_admin": True,
        "company_name": "Test Company"
    }

# --- Test register_user ---
@pytest.mark.asyncio
async def test_register_user_success(auth_service, mock_user_repository, register_data):
    mock_user_repository.get_user_by_email.return_value = None
    mock_user_repository.create_user.return_value = None # create_user doesn't return anything specific

    response = await auth_service.register_user(register_data)

    mock_user_repository.get_user_by_email.assert_called_once_with(register_data.email)
    mock_user_repository.create_user.assert_called_once()
    created_user_data = mock_user_repository.create_user.call_args[0][0]
    assert created_user_data["email"] == register_data.email
    # The actual hash will be generated by the real CryptContext, so we can't assert a fixed string
    # Instead, we assert that a hash was generated and it's not the plain password
    assert created_user_data["password"] != register_data.password
    # Ensure 'approved_by_admin' is present and False
    assert "approved_by_admin" in created_user_data
    assert created_user_data["approved_by_admin"] is False
    assert isinstance(response, RegisterResponseSchema)
    assert response.msg == "Đăng ký thành công. Vui lòng chờ quản trị viên phê duyệt."

@pytest.mark.asyncio
async def test_register_user_email_exists(auth_service, mock_user_repository, register_data, mock_user_model_data):
    mock_user_repository.get_user_by_email.return_value = mock_user_model_data

    with pytest.raises(EmailAlreadyExistsError):
        await auth_service.register_user(register_data)

    mock_user_repository.get_user_by_email.assert_called_once_with(register_data.email)
    mock_user_repository.create_user.assert_not_called()

# --- Test login_user ---
@pytest.mark.asyncio
async def test_login_user_success(auth_service, mock_user_repository, login_data, mock_user_model_data, mocker):
    mock_user_repository.get_user_by_email.return_value = mock_user_model_data
    # Use mocker.patch for better pytest integration and automatic cleanup
    mocker.patch('src.services.auth_service.auth_service.pwd_context', pwd_context_mock)
    response = await auth_service.login_user(login_data)

    mock_user_repository.get_user_by_email.assert_called_once_with(login_data.email)
    pwd_context_mock.verify.assert_called_once_with(login_data.password, mock_user_model_data["password"])
    assert isinstance(response, LoginResponseSchema)
    assert response.user.email == mock_user_model_data["email"]
    assert str(response.user.id) == mock_user_model_data["id"] # Convert ObjectId to string for comparison
    assert response.user.company_name == mock_user_model_data["company_name"]
    assert response.token is not None
    # Optionally, decode token to verify content
    decoded_token = decode_access_token(response.token)
    assert decoded_token["sub"] == mock_user_model_data["id"]

@pytest.mark.asyncio
async def test_login_user_invalid_credentials_no_user(auth_service, mock_user_repository, login_data, mocker):
    mock_user_repository.get_user_by_email.return_value = None
    mocker.patch('src.services.auth_service.auth_service.pwd_context', pwd_context_mock)

    with pytest.raises(InvalidCredentialsError):
        await auth_service.login_user(login_data)

    mock_user_repository.get_user_by_email.assert_called_once_with(login_data.email)
    # pwd_context_mock.verify.assert_not_called() # This assertion might fail if the mock is not properly isolated

@pytest.mark.asyncio
async def test_login_user_invalid_credentials_wrong_password(auth_service, mock_user_repository, login_data, mock_user_model_data, mocker):
    mock_user_repository.get_user_by_email.return_value = mock_user_model_data
    pwd_context_mock.verify.return_value = False # Simulate wrong password

    # Use mocker.patch for better pytest integration and automatic cleanup
    mocker.patch('src.services.auth_service.auth_service.pwd_context', pwd_context_mock)

    with pytest.raises(InvalidCredentialsError):
        await auth_service.login_user(login_data)

    mock_user_repository.get_user_by_email.assert_called_once_with(login_data.email)
    pwd_context_mock.verify.assert_called_once_with(login_data.password, mock_user_model_data["password"])

# --- Test get_current_user ---
@pytest.mark.asyncio
async def test_get_current_user_success(auth_service, mock_user_repository, mock_user_model_data):
    user_id = mock_user_model_data["id"]
    mock_user_repository.get_user_by_id.return_value = mock_user_model_data

    user = await auth_service.get_current_user(user_id)

    mock_user_repository.get_user_by_id.assert_called_once_with(user_id)
    assert isinstance(user, UserSchema)
    assert str(user.id) == user_id # Convert ObjectId to string for comparison
    assert user.email == mock_user_model_data["email"]

@pytest.mark.asyncio
async def test_get_current_user_not_found(auth_service, mock_user_repository):
    user_id = "non_existent_id"
    mock_user_repository.get_user_by_id.return_value = None

    with pytest.raises(UserNotFoundError):
        await auth_service.get_current_user(user_id)

    mock_user_repository.get_user_by_id.assert_called_once_with(user_id)
